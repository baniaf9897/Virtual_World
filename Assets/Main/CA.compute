// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

RWTexture3D <float4>    Automatum;

int                     width;
int                     height;
int                     depth;
float                   currentLayer;
 
float3 random3(float3 c) {
    float j = 4096.0 * sin(dot(c, float3(17.0, 59.4, 15.0)));
    float3 r;
    r.z = frac(512.0 * j);
    j *= .125;
    r.x = frac(512.0 * j);
    j *= .125;
    r.y = frac(512.0 * j);
    return r - 0.5;
}

/* skew constants for 3d simplex functions */
const float F3 = 0.3333333;
const float G3 = 0.1666667;

/* 3d simplex noise */
float simplex3d(float3 p) {
    /* 1. find current tetrahedron T and it's four vertices */
    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */
    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/

    /* calculate s and x */
    float3 s = floor(p + dot(p, float3(F3, F3, F3)));
    float3 x = p - s + dot(s, float3(G3,G3,G3));

    /* calculate i1 and i2 */
    float3 e = step(float3(0.0,0.0,0.0), x - x.yzx);
    float3 i1 = e * (1.0 - e.zxy);
    float3 i2 = 1.0 - e.zxy * (1.0 - e);

    /* x1, x2, x3 */
    float3 x1 = x - i1 + G3;
    float3 x2 = x - i2 + 2.0 * G3;
    float3 x3 = x - 1.0 + 3.0 * G3;

    /* 2. find four surflets and store them in d */
    float4 w, d;

    /* calculate surflet weights */
    w.x = dot(x, x);
    w.y = dot(x1, x1);
    w.z = dot(x2, x2);
    w.w = dot(x3, x3);

    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */
    w = max(0.6 - w, 0.0);

    /* calculate surflet components */
    d.x = dot(random3(s), x);
    d.y = dot(random3(s + i1), x1);
    d.z = dot(random3(s + i2), x2);
    d.w = dot(random3(s + 1.0), x3);

    /* multiply d by w^4 */
    w *= w;
    w *= w;
    d *= w;

    /* 3. return the sum of the four surflets */
    return dot(d, float4(52.0, 52.0, 52.0, 52.0));
}


float2 hash22(float2 p)
{
    p = float2(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)));
    return -1.0 + 2.0 * frac(sin(p) * 43758.5453123);
}

float Perlin(float2 p)
{
    float2 pi = floor(p);//Return the largest integer less than or equal to x.
    float2 pf = frac(p);//Returns the decimal part of the input value.

    //float2 w = pf * pf * (3.0 - 2.0 * pf);
    float2 w = pf * pf * pf * (6 * pf * pf - 15 * pf + 10);

    return lerp(lerp(dot(hash22(pi + float2(0.0, 0.0)), pf - float2(0.0, 0.0)),
        dot(hash22(pi + float2(1.0, 0.0)), pf - float2(1, 0.0)), w.x),
        lerp(dot(hash22(pi + float2(0.0, 1.0)), pf - float2(0.0, 1.0)),
            dot(hash22(pi + float2(1.0, 1.0)), pf - float2(1.0, 1.0)), w.x), w.y);
}

float random(float2 uv) {
    return frac(sin(dot(uv, float2(64.9898, 138.233))) * 43758.5453123);
}

float rand(float2 co) { return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453); }

float RandomValue(float3 uvw) {
    return rand(uvw.xz);
}

float3 RandomColor(float3 uvw) {
    return float3(random(uvw.xz), random(uvw.xz), random(uvw.xz));
}


//https://softologyblog.wordpress.com/2019/12/28/3d-cellular-automata-3/
float Get445(float sum, float state) {

    if (state > 0.0) {
        if (sum < 2 || sum == 4) {
            return 0;
        }
        else if (sum == 3 || sum == 3) {
            return 1;
        }


    }
    else {
        if (sum == 3) {
            return 1;
        }
    }

    return 0;
}

//https://mathworld.wolfram.com/ElementaryCellularAutomaton.html
float Get30(float front, float middle , float back, float3 id) {
   
    if ((front && middle) || (front && back) || (!front && !back && !middle)) {
        return 0;
    }

    return 1;
}

float GetValue(float3 id) {
        
        //edge-cases
        if (id.x == 0 || id.y == 0 || id.z == 0 || id.z == depth - 1 || id.y == height -1 || id.x == width -1) {
            return 0.0;
        }


        int oldY = id.y - 1;

        // bottom layer
        float bf = Automatum[float3(id.x, oldY, id.z + 1)].a;
        float blf = Automatum[float3(id.x - 1, oldY, id.z + 1)].a;
        float brf = Automatum[float3(id.x + 1, oldY, id.z + 1)].a;

        float bb = Automatum[float3(id.x, oldY, id.z - 1)].a;
        float blb = Automatum[float3(id.x - 1, oldY, id.z - 1)].a;
        float brb = Automatum[float3(id.x + 1, oldY, id.z - 1)].a;

        float bl = Automatum[float3(id.x - 1, oldY, id.z)].a;
        float br = Automatum[float3(id.x + 1, oldY, id.z)].a;
        float bm = Automatum[float3(id.x, oldY, id.z)].a;

        //middle layer

        float mf = Automatum[float3(id.x, id.y, id.z + 1)].a;
        float mlf = Automatum[float3(id.x - 1, id.y, id.z + 1)].a;
        float mrf = Automatum[float3(id.x + 1, id.y, id.z + 1)].a;

        float mb = Automatum[float3(id.x, id.y, id.z - 1)].a;
        float mlb = Automatum[float3(id.x - 1, id.y, id.z - 1)].a;
        float mrb = Automatum[float3(id.x + 1, id.y, id.z - 1)].a;

        float ml = Automatum[float3(id.x - 1, id.y, id.z)].a;
        float mr = Automatum[float3(id.x + 1, id.y, id.z)].a;
        float mm = Automatum[float3(id.x, id.y, id.z)].a;

        //top layer

        float tf = Automatum[float3(id.x, id.y + 1, id.z + 1)].a;
        float tlf = Automatum[float3(id.x - 1, id.y + 1, id.z + 1)].a;
        float trf = Automatum[float3(id.x + 1, id.y + 1, id.z + 1)].a;

        float tb = Automatum[float3(id.x, id.y + 1, id.z - 1)].a;
        float tlb = Automatum[float3(id.x - 1, id.y + 1, id.z - 1)].a;
        float trb = Automatum[float3(id.x + 1, id.y + 1, id.z - 1)].a;

        float tl = Automatum[float3(id.x - 1, id.y + 1, id.z)].a;
        float tr = Automatum[float3(id.x + 1, id.y + 1, id.z)].a;
        float tm = Automatum[float3(id.x, id.y + 1, id.z)].a;

        /* int sum2 =   ceil(bf) + ceil( blf) + ceil(brf) + ceil(bb) + ceil(blb) + ceil(brb) + ceil(bl) + ceil(br) + ceil(bm) + 
                    ceil(tf) + ceil(tlf) + ceil(trf) + ceil(tb) + ceil(tlb) + ceil(trb) + ceil(tl) + ceil(tr) + ceil(tm) + 
                    ceil(mf) + ceil(mlf) + ceil(mrf) + ceil(mb) + ceil(mlb) + ceil(mrb) + ceil(ml) + ceil(mr); */

                   
       //float sum = bf + blf +  brf  +  bb  +  blb  +  brb  +  bl  +  br  +  bm  + tf  +  tlf  +  trf  + tb  +  tlb + trb  + tl + tr + tm + mf  + mlf + mrf + mb + mlb + mrb + ml + mr;

       float sum2D = ceil(bf) + ceil(blf) + ceil(brf) + ceil(bb) + ceil(blb) + ceil(brb) + ceil(bl) + ceil(br) + ceil(bm) ;
       float sum1D = ceil(bf) + ceil(bb) + ceil(bm);


       float rule = simplex3d(id/  float3(width, height, depth)) * (id.y/height);


       if (id.y/height >= 0.3) {
           return Get30(ceil(bf), ceil(bm), ceil(bb),id);


       }
       else {
           return Get445(sum2D, bm);

       }
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 uvw = (float3)id.xyz / float3(width, height, depth);
    float v = 0.0;
 
   /* if (currentLayer == 0 && id.y < 1) {
        
        v = RandomValue(uvw);
        if (v < 0.5) {
            v = 0;
        }
        else {
            v = 1;
        }
        
       
    }
    else {
        v = GetValue(id);
    }
    float4 cell = 0;
    cell.rgb = uvw.y;
    cell.a = v;
    Automatum[id] = cell;*/

    int gen = floor(currentLayer);

    if (gen == id.y) {
        if (gen == 0) {
            v = RandomValue(uvw);
            if (v < 0.5) {
                v = 0;
            }
            else {
                v = 1;
            }
        }
        else {
            if (frac(currentLayer) == 0) {
                v =  GetValue(id);
            }else{
                v = GetValue(id) * frac(currentLayer);
            }
        }
        float4 cell = 0;
        cell.rgb = uvw.y;
        cell.a = v;
        Automatum[id] = cell;

    }

}
