// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

RWTexture3D <float4>    Automatum;

int                     width;
int                     height;
int                     depth;
float                   currentLayer;
 
float2 hash22(float2 p)
{
    p = float2(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)));
    return -1.0 + 2.0 * frac(sin(p) * 43758.5453123);
}

float Perlin(float2 p)
{
    float2 pi = floor(p);//Return the largest integer less than or equal to x.
    float2 pf = frac(p);//Returns the decimal part of the input value.

    //float2 w = pf * pf * (3.0 - 2.0 * pf);
    float2 w = pf * pf * pf * (6 * pf * pf - 15 * pf + 10);

    return lerp(lerp(dot(hash22(pi + float2(0.0, 0.0)), pf - float2(0.0, 0.0)),
        dot(hash22(pi + float2(1.0, 0.0)), pf - float2(1, 0.0)), w.x),
        lerp(dot(hash22(pi + float2(0.0, 1.0)), pf - float2(0.0, 1.0)),
            dot(hash22(pi + float2(1.0, 1.0)), pf - float2(1.0, 1.0)), w.x), w.y);
}

float random(float2 uv) {
    return frac(sin(dot(uv, float2(64.9898, 138.233))) * 43758.5453123);
}

float rand(float2 co) { return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453); }

float RandomValue(float3 uvw) {
    return rand(uvw.xz);
}

float3 RandomColor(float3 uvw) {
    return float3(random(uvw.xz), random(uvw.xz), random(uvw.xz));
}

float GetValue(float3 id) {
        
        //edge-cases
        if (id.x == 0 || id.y == 0 || id.z == 0 || id.z == depth - 1 || id.y == height -1 || id.x == width -1) {
            return 0.0;
        }


        int oldY = id.y - 1;

        // bottom layer
        float bf = Automatum[float3(id.x, oldY, id.z + 1)].a;
        float blf = Automatum[float3(id.x - 1, oldY, id.z + 1)].a;
        float brf = Automatum[float3(id.x + 1, oldY, id.z + 1)].a;

        float bb = Automatum[float3(id.x, oldY, id.z - 1)].a;
        float blb = Automatum[float3(id.x - 1, oldY, id.z - 1)].a;
        float brb = Automatum[float3(id.x + 1, oldY, id.z - 1)].a;

        float bl = Automatum[float3(id.x - 1, oldY, id.z)].a;
        float br = Automatum[float3(id.x + 1, oldY, id.z)].a;
        float bm = Automatum[float3(id.x, oldY, id.z)].a;

        //middle layer

        float mf = Automatum[float3(id.x, id.y, id.z + 1)].a;
        float mlf = Automatum[float3(id.x - 1, id.y, id.z + 1)].a;
        float mrf = Automatum[float3(id.x + 1, id.y, id.z + 1)].a;

        float mb = Automatum[float3(id.x, id.y, id.z - 1)].a;
        float mlb = Automatum[float3(id.x - 1, id.y, id.z - 1)].a;
        float mrb = Automatum[float3(id.x + 1, id.y, id.z - 1)].a;

        float ml = Automatum[float3(id.x - 1, id.y, id.z)].a;
        float mr = Automatum[float3(id.x + 1, id.y, id.z)].a;
        float mm = Automatum[float3(id.x, id.y, id.z)].a;

        //top layer

        float tf = Automatum[float3(id.x, id.y + 1, id.z + 1)].a;
        float tlf = Automatum[float3(id.x - 1, id.y + 1, id.z + 1)].a;
        float trf = Automatum[float3(id.x + 1, id.y + 1, id.z + 1)].a;

        float tb = Automatum[float3(id.x, id.y + 1, id.z - 1)].a;
        float tlb = Automatum[float3(id.x - 1, id.y + 1, id.z - 1)].a;
        float trb = Automatum[float3(id.x + 1, id.y + 1, id.z - 1)].a;

        float tl = Automatum[float3(id.x - 1, id.y + 1, id.z)].a;
        float tr = Automatum[float3(id.x + 1, id.y + 1, id.z)].a;
        float tm = Automatum[float3(id.x, id.y + 1, id.z)].a;

        /*int sum =   ceil(bf) + ceil( blf) + ceil(brf) + ceil(bb) + ceil(blb) + ceil(brb) + ceil(bl) + ceil(br) + ceil(bm) + 
                    ceil(tf) + ceil(tlf) + ceil(trf) + ceil(tb) + ceil(tlb) + ceil(trb) + ceil(tl) + ceil(tr) + ceil(tm) + 
                    ceil(mf) + ceil(mlf) + ceil(mrf) + ceil(mb) + ceil(mlb) + ceil(mrb) + ceil(ml) + ceil(mr);*/

                   
       //float sum = bf + blf +  brf  +  bb  +  blb  +  brb  +  bl  +  br  +  bm  + tf  +  tlf  +  trf  + tb  +  tlb + trb  + tl + tr + tm + mf  + mlf + mrf + mb + mlb + mrb + ml + mr;

       float sum = ceil(bf) + ceil(blf) + ceil(brf) + ceil(bb) + ceil(blb) + ceil(brb) + ceil(bl) + ceil(br) + ceil(bm);
 
        if (mm > 0.0) {
            if (sum < 2 || sum == 4) {
                return 0;
             }
            else if (sum == 3 || sum == 3) {
                return 1;
            }
    
          
        }
        else {
            if (sum == 3){
                return 1;
            }
         }

        return 0;
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 uvw = (float3)id.xyz / float3(width, height, depth);
    float v = 0.0;
 
   /* if (currentLayer == 0 && id.y < 1) {
        
        v = RandomValue(uvw);
        if (v < 0.5) {
            v = 0;
        }
        else {
            v = 1;
        }
        
       
    }
    else {
        v = GetValue(id);
    }
    float4 cell = 0;
    cell.rgb = uvw.y;
    cell.a = v;
    Automatum[id] = cell;*/

    int gen = floor(currentLayer);

    if (gen == id.y) {
        if (gen == 0) {
            v = RandomValue(uvw);
            if (v < 0.5) {
                v = 0;
            }
            else {
                v = 1;
            }
        }
        else {
            if (frac(currentLayer) == 0) {
                v =  GetValue(id);
            }else{
                v = GetValue(id) * frac(currentLayer);
            }
        }
        float4 cell = 0;
        cell.rgb = uvw.y;
        cell.a = v;
        Automatum[id] = cell;

    }

}
